% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/where.R
\name{tf_where}
\alias{tf_where}
\alias{tf_anywhere}
\alias{in_range}
\alias{\%inr\%}
\title{Find out where functional data fulfills certain conditions.}
\usage{
tf_where(f, cond, return = c("all", "first", "last", "range", "any"), arg)

tf_anywhere(f, cond, arg)

in_range(f, r)

f \%inr\% r
}
\arguments{
\item{f}{a \code{tf} object}

\item{cond}{a logical expression on \code{value} that defines the condition about
the function values, see examples and details.}

\item{return}{for each entry in \code{f}, \code{tf_where} either returns \emph{all} \code{arg} for
which \code{cond} is true, the \emph{first}, the \emph{last} or their \emph{range} or logical
flags whether the functions fullfill the condition \emph{any}where. For
\code{"range"}, note that \code{cond} may not be true for all \code{arg} values in this
range, though, this is not checked.}

\item{arg}{optional \code{arg}-values on which to evaluate \code{f} and check \code{cond},
defaults to \code{tf_arg(f)}.}

\item{r}{numeric vector used to specify a range, only the minimum and maximum of \code{r} are used.}
}
\value{
depends on  \code{return}:
\itemize{
\item \code{return = "any"}, i.e, \code{anywhere}: a logical vector of the same length as \code{f}.
\item \code{return = "all"}: a list of vectors of the same length as \code{f}, with
empty vectors for the functions that  never fulfill the \code{cond}ition.
\item \code{return = "range"}: a data frame with columns "begin" and "end".
\item else, a numeric vector of the same length as \code{f} with \code{NA}s for the functions that  never fulfill the \code{cond}ition.
}
}
\description{
\code{tf_where} allows to define a logical expression about the function values
and returns the argument values for which that condition is true.\cr
\code{tf_anywhere} is syntactic sugar for \code{tf_where} with \code{return = "any"} to
get a logical flag for each function if the condition is \code{TRUE} \emph{anywhere},
see below.

\code{in_range} and its infix-equivalent \verb{\%inr\%} return \code{TRUE} for all
values in the numeric vector \code{f} that are within the range of values in \code{r}.
}
\details{
Entries in \code{f} that do not fulfill \code{cond} anywhere yield \code{numeric(0)}.\cr
\code{cond}  is evaluated as a \code{\link[dplyr:filter]{dplyr::filter()}}-statement on a \code{data.frame}
containing a single entry in \code{f} with columns \code{arg} and \code{value}, so all
the usual \code{dplyr} tricks are available, see examples.\cr
Any condition evaluates to \code{NA} on \code{NA}-entries in \code{f}.
}
\examples{
  lin <- 1:4 * tfd(seq(-1, 1,l = 11), seq(-1, 1, l = 11))
  tf_where(lin, value \%inr\% c(-1, .5))
  tf_where(lin, value \%inr\% c(-1, .5), "range")
  a <- 1
  tf_where(lin, value > a, "first")
  tf_where(lin, value < a, "last")
  tf_where(lin, value > 2, "any")
  tf_anywhere(lin, value > 2)

  set.seed(4353)
  plot(f <- tf_rgp(5, 11L), pch = as.character(1:5), points = TRUE)
  tf_where(f, value == max(value))
  # where is the function increasing/decreasing:
  tf_where(f, value > dplyr::lag(value, 1, value[1]))
  tf_where(f, value < dplyr::lead(value, 1, value[dplyr::n()]))
  # where are the (interior) extreme points:
  tf_where(f,
    sign(c(diff(value)[1], diff(value))) !=
      sign(c(diff(value), diff(value)[dplyr::n()-1])))
  # where for arg > .5 is the function positive:
  tf_where(f, arg > .5 & value > 0)
  # does the function ever exceed 1:
  tf_anywhere(f, value > 1)
}
