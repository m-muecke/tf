% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tfb-fpc.R
\name{tfb_fpc}
\alias{tfb_fpc}
\alias{tfb_fpc.data.frame}
\alias{tfb_fpc.matrix}
\alias{tfb_fpc.numeric}
\alias{tfb_fpc.tf}
\alias{tfb_fpc.default}
\title{Functional data in FPC-basis representation}
\usage{
tfb_fpc(data, ...)

\method{tfb_fpc}{data.frame}(
  data,
  id = 1,
  arg = 2,
  value = 3,
  domain = NULL,
  method = fpc_wsvd,
  resolution = NULL,
  ...
)

\method{tfb_fpc}{matrix}(
  data,
  arg = NULL,
  domain = NULL,
  method = fpc_wsvd,
  resolution = NULL,
  ...
)

\method{tfb_fpc}{numeric}(
  data,
  arg = NULL,
  domain = NULL,
  method = fpc_wsvd,
  resolution = NULL,
  ...
)

\method{tfb_fpc}{tf}(data, arg = NULL, method = fpc_wsvd, ...)

\method{tfb_fpc}{default}(
  data,
  arg = NULL,
  domain = NULL,
  method = fpc_wsvd,
  resolution = NULL,
  ...
)
}
\arguments{
\item{data}{a \code{matrix}, \code{data.frame} or \code{list} of suitable shape, or another
\code{tf}-object containing functional data.}

\item{...}{arguments to the \code{method} which computes the
(regularized/smoothed) FPCA.
Unless set by the user \code{tidyfun} uses proportion of variance explained
\code{pve = .995} to determine the truncation levels.}

\item{id}{The name or number of the column defining which data belong to which function.}

\item{arg}{a grid of argument values to evaluate on.}

\item{value}{The name or number of the column containing the function evaluations.}

\item{domain}{range of the \code{arg}.}

\item{method}{the function to use that computes eigenfunctions and scores.
Defaults to \code{\link[=fpc_wsvd]{fpc_wsvd()}}, which gives unsmoothed eigenfunctions.}

\item{resolution}{resolution of the evaluation grid. See details for \code{\link[=tfd]{tfd()}}.}
}
\value{
an object of class \code{tfb_fpc}, inheriting from \code{tfb}.
The basis used by \code{tfb_fpc} is a \code{tfd}-vector containing the estimated
mean and eigenfunctions.
}
\description{
These functions perform a (functional) principal component analysis (FPCA) of
the input data and return an \code{tfb_fpc} \code{tf}-object that uses the empirical
eigenfunctions as basis functions for representing the data. By default, a
simple, not smoothed, truncated weighted SVD of the functions is used to
compute those ("\code{method = fpc_wsvd}"). Note that this is suitable only for
regular data all observed on the same (not necessarily equidistant) grid. See
Details / Example for possible alternatives and extensions. \cr
}
\details{
Any "factorization" method that accepts a \code{data.frame} with
columns \code{id}, \code{arg}, \code{value} containing the functional data and returns a
list structured like the return object
of \code{\link[=fpc_wsvd]{fpc_wsvd()}} can be used for the `method`` argument, see example below.
}
\section{Methods (by class)}{
\itemize{
\item \code{default}: convert \code{tfb}: default method, returning prototype when data is NULL
}}

\examples{
# Apply FPCA for sparse data using refund::fpca.sc:
set.seed(99290)
# create sparse data:
data <- tf_rgp(15) |> tf_sparsify() |> as.data.frame(unnest = TRUE)
# wrap refund::fpca_sc for use as FPCA method in tfb_fpc:
fpca_sc_wrapper <- function(data, arg, pve = .995, ...) {
  data_mat <- tidyfun:::df_2_mat(data)
  fpca <- refund::fpca.sc(Y = data_mat, 
                          argvals = attr(data_mat, "arg"), 
                          pve = pve, ...)
  fpca[c("mu", "efunctions", "scores", "npc")]
}
tfb_fpc(data, method = fpca_sc_wrapper)
}
\seealso{
\code{\link[=tfb]{tfb()}},  \code{\link[=fpc_wsvd]{fpc_wsvd()}} for FPCA options.
}
