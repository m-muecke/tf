% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/convert.R, R/tfd-class.R
\name{as.tfd}
\alias{as.tfd}
\alias{as.tfd_irreg}
\alias{as.data.frame.tf}
\alias{as.matrix.tfd}
\alias{tfd}
\alias{tfd.matrix}
\alias{tfd.numeric}
\alias{tfd.data.frame}
\alias{tfd.list}
\alias{tfd.tf}
\alias{tfd.default}
\title{Constructors & converters for "raw" functional data}
\usage{
as.tfd(data, ...)

as.tfd_irreg(data, ...)

\method{as.data.frame}{tf}(x, row.names = NULL, optional = FALSE, ...)

\method{as.matrix}{tfd}(x, arg = NULL, interpolate = FALSE, ...)

tfd(data, ...)

\method{tfd}{matrix}(
  data,
  arg = NULL,
  domain = NULL,
  evaluator = tf_approx_linear,
  resolution = NULL,
  ...
)

\method{tfd}{numeric}(
  data,
  arg = NULL,
  domain = NULL,
  evaluator = tf_approx_linear,
  resolution = NULL,
  ...
)

\method{tfd}{data.frame}(
  data,
  id = 1,
  arg = 2,
  value = 3,
  domain = NULL,
  evaluator = tf_approx_linear,
  resolution = NULL,
  ...
)

\method{tfd}{list}(
  data,
  arg = NULL,
  domain = NULL,
  evaluator = tf_approx_linear,
  resolution = NULL,
  ...
)

\method{tfd}{tf}(data, arg = NULL, domain = NULL, evaluator = NULL, resolution = NULL, ...)

\method{tfd}{default}(
  data,
  arg = NULL,
  domain = NULL,
  evaluator = tf_approx_linear,
  resolution = NULL,
  ...
)
}
\arguments{
\item{data}{a \code{matrix}, \code{data.frame} or \code{list} of suitable shape, or another \code{tf}-object. when
this argument is \code{NULL} (i.e. when calling \code{tfd()}) this returns a prototype of class \code{tfd}}

\item{...}{not used in \code{tfd}, except for \code{tfd.tf} -- specify \code{arg} and \code{ìnterpolate = TRUE} to
turn an irregular \code{tfd} into a regular one, see examples.}

\item{x}{a \code{tf} object}

\item{optional}{not used!}

\item{arg}{\code{numeric}, or list of \code{numeric}s. The evaluation grid. See Details on its
interplay with \code{resolution}.
For the \code{data.frame}-method: the name/number of the column defining the
evaluation grid. The \code{matrix} method will try to guess suitable \code{arg}-values
from the column names of \code{data} if \code{arg} is not supplied. Other methods fall back on
integer sequences (\verb{1:<length of data>}) as the default if not provided.}

\item{domain}{range of the \code{arg}.}

\item{evaluator}{a function accepting arguments \verb{x, arg, evaluations}. See details for \code{\link[=tfd]{tfd()}}.}

\item{resolution}{resolution of the evaluation grid. See details for \code{\link[=tfd]{tfd()}}.}

\item{id}{The name/number of the column defining which data belong to which function.}

\item{value}{The name/number of the column containing the function evaluations.}
}
\value{
a one-column \code{data.frame} with a \code{tf}-column containing \code{x}

an \code{tfd}-object (or a \code{data.frame}/\code{matrix} for the conversion functions, obviously.)
}
\description{
Various constructor and conversion methods.

\code{tfd.data.frame} uses the first 3 columns of \code{data} for function information by default:
(\code{ìd}, \code{arg}, \code{value})

\code{tfd.list} accepts a list of vectors of identical lengths
containing evaluations or a list of 2-column matrices/data.frames with
\code{arg} in the first and evaluations in the second column

return class prototype when argument to tfd() is NULL or not a recognised class
}
\details{
\strong{\code{evaluator}}: must be the (quoted or bare) name of a
function with signature \verb{function(x, arg, evaluations)} that returns
the functions' (approximated/interpolated) values at locations \code{x} based on
the function \code{evaluations} available at locations \code{arg}.\cr
Available \code{evaluator}-functions:
\itemize{
\item \code{tf_approx_linear} for linear interpolation without extrapolation (i.e.,
\code{\link[zoo:na.approx]{zoo::na.approx()}} with \code{na.rm = FALSE})  -- this is the default,
\item \code{tf_approx_spline} for cubic spline interpolation, (i.e., \code{\link[zoo:na.approx]{zoo::na.spline()}}
with \code{na.rm = FALSE}),
\item \code{tf_approx_fill_extend} for linear interpolation and constant extrapolation
(i.e., \code{\link[zoo:na.fill]{zoo::na.fill()}} with \code{fill = "extend"})
\item \code{tf_approx_locf} for "last observation carried forward"  (i.e.,
\code{\link[zoo:na.locf]{zoo::na.locf()}} with \code{na.rm = FALSE} and
\item \code{tf_approx_nocb} for "next observation carried backward" (i.e.,
\code{\link[zoo:na.locf]{zoo::na.locf()}} with \verb{na.rm = FALSE, fromLast = TRUE}).
See \code{tidyfun:::zoo_wrapper} and \code{tidyfun:::tf_approx_linear}, which is simply
\code{zoo_wrapper(zoo::na.tf_approx, na.rm = FALSE)}, for examples of implementations of
this.
}

\strong{\code{resolution}}: \code{arg}-values that are equivalent up to this difference are
treated as identical. E.g., if an evaluation of \eqn{f(t)} is available at \eqn{t=1}
and a function value is requested at \eqn{t = 1.01}, \eqn{f(1)} will be returned if
\code{resolution} < .01. By default, resolution will be set to an integer-valued power
of 10 one smaller than the smallest difference between adjacent
\code{arg}-values rounded down to an integer-valued power
of 10: e.g., if the smallest difference between consecutive
\code{arg}-values is between 0.1 and 0.9999, the resolution will be 0.01, etc.
In code: \verb{resolution = 10^(floor(log10(min(diff(<arg>))) - 1)}
}
\examples{
#turn irregular to regular tfd by evaluating on a common grid:

(f <- c(tf_rgp(1, arg = seq(0,1,l=11)), tf_rgp(1, arg = seq(0,1,l=21))))
tfd(f, arg = seq(0, 1, l = 21))

(f <- c(dti_df$cca[1], dti_df$rcst[2]))
#does not yield regular data because linear extrapolation yields NAs outside observed range:
tfd(f, arg = seq(0, 1, l = 101)) 
# this "works" (but may not yield sensible values..!!) for e.g. constant extrapolation:
tfd(f, evaluator = tf_approx_fill_extend, arg = seq(0, 1, l = 101))
plot(f, col = 2)
lines(tfd(f, evaluator = tf_approx_fill_extend, arg = seq(0, 1, l = 151)))
}
